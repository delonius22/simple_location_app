#!/usr/bin/env python3
"""
RSA-TOTP Hybrid Encryption System for JSON data.
This module provides the core functionality for secure encryption and decryption
of JSON data using RSA encryption combined with TOTP authentication.
"""

import os
import sys
import json
import argparse
import base64
import datetime
from pathlib import Path
from typing import Dict, Any, Tuple, Optional

from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

import pyotp

# Import other modules from our package
from .key_manager import KeyManager
from .audit_logger import AuditLogger
from .qr_generator import TOTPQRGenerator


class RSATOTPCrypto:
    """
    Core encryption/decryption class using RSA with TOTP verification.
    
    Implements a hybrid cryptosystem where:
    1. Data is encrypted with AES (symmetric)
    2. The AES key is encrypted with RSA (asymmetric)
    3. Decryption requires a valid TOTP code
    """
    
    def __init__(self, config_dir: str = None):
        """
        Initialize the encryption system.
        
        Args:
            config_dir: Directory containing configuration and keys
        """
        self.config_dir = Path(config_dir) if config_dir else Path("./config")
        self.config_dir.mkdir(exist_ok=True, parents=True)
        
        # Initialize key manager
        self.key_manager = KeyManager(self.config_dir)
        
        # Initialize audit logger
        logs_dir = Path("./logs")
        logs_dir.mkdir(exist_ok=True, parents=True)
        self.audit_logger = AuditLogger(logs_dir / "access.log")
        
        # TOTP settings
        self.totp_window = 90  # 90-second window for TOTP codes
        self.totp_digits = 8   # 8-digit TOTP codes
    
    def initialize_system(self, issuer: str, user_email: str) -> str:
        """
        Initialize the system with new RSA keys and TOTP setup.
        
        Args:
            issuer: The issuer name for the TOTP
            user_email: The user email for the TOTP
        
        Returns:
            Path to the generated QR code image
        """
        # Generate RSA key pair if not exists
        if not self.key_manager.has_current_keys():
            self.key_manager.generate_keypair()
            
        # Generate TOTP secret and QR code
        totp_secret = pyotp.random_base32()
        
        # Store TOTP secret (in real-world scenario, this would be encrypted)
        totp_config_path = self.config_dir / "totp_secret.json"
        with open(totp_config_path, 'w') as f:
            json.dump({
                "secret": totp_secret,
                "issuer": issuer,
                "user": user_email,
                "digits": self.totp_digits,
                "interval": self.totp_window
            }, f)
        
        # Generate QR code
        qr_generator = TOTPQRGenerator()
        qr_path = qr_generator.generate_totp_qr(
            totp_secret, 
            issuer, 
            user_email,
            digits=self.totp_digits,
            interval=self.totp_window
        )
        
        self.audit_logger.log_event(
            "SYSTEM_INIT",
            "SUCCESS",
            user_email,
            details="System initialized with new keys and TOTP"
        )
        
        return qr_path
    
    def _generate_aes_key(self) -> bytes:
        """Generate a random AES key."""
        return os.urandom(32)  # 256-bit key
    
    def _encrypt_with_aes(self, data: bytes, key: bytes) -> Tuple[bytes, bytes]:
        """
        Encrypt data with AES-256-GCM.
        
        Returns:
            Tuple of (iv, ciphertext)
        """
        iv = os.urandom(12)  # GCM standard nonce length
        cipher = Cipher(
            algorithms.AES(key),
            modes.GCM(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(data) + encryptor.finalize()
        
        return iv, ciphertext + encryptor.tag
    
    def _decrypt_with_aes(self, ciphertext: bytes, key: bytes, iv: bytes) -> bytes:
        """Decrypt data with AES-256-GCM."""
        cipher = Cipher(
            algorithms.AES(key),
            modes.GCM(iv),
            backend=default_backend()
        )
        
        # Extract tag from ciphertext (last 16 bytes)
        tag = ciphertext[-16:]
        actual_ciphertext = ciphertext[:-16]
        
        # Create decryptor with tag
        decryptor = cipher.decryptor()
        
        # Decrypt the data
        plaintext = decryptor.update(actual_ciphertext) + decryptor.finalize_with_tag(tag)
        return plaintext
    
    def _encrypt_aes_key_with_rsa(self, aes_key: bytes) -> bytes:
        """Encrypt the AES key using RSA public key."""
        public_key = self.key_manager.load_public_key()
        
        encrypted_key = public_key.encrypt(
            aes_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return encrypted_key
    
    def _decrypt_aes_key_with_rsa(self, encrypted_key: bytes, totp_code: str) -> Optional[bytes]:
        """
        Decrypt the AES key using RSA private key.
        
        Args:
            encrypted_key: RSA-encrypted AES key
            totp_code: TOTP code for authentication
            
        Returns:
            Decrypted AES key if TOTP code is valid, None otherwise
        """
        # Verify TOTP code
        if not self._verify_totp(totp_code):
            return None
            
        private_key = self.key_manager.load_private_key()
        
        decrypted_key = private_key.decrypt(
            encrypted_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return decrypted_key
    
    def _verify_totp(self, totp_code: str) -> bool:
        """Verify the provided TOTP code."""
        totp_config_path = self.config_dir / "totp_secret.json"
        
        if not totp_config_path.exists():
            raise FileNotFoundError("TOTP configuration not found. Please initialize the system first.")
            
        with open(totp_config_path, 'r') as f:
            totp_config = json.load(f)
            
        totp = pyotp.TOTP(
            totp_config["secret"],
            digits=totp_config["digits"],
            interval=totp_config["interval"]
        )
        
        # Verify with a window to account for timing differences
        return totp.verify(totp_code)
    
    def encrypt_json(self, json_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Encrypt JSON data.
        
        Args:
            json_data: JSON data to encrypt
            
        Returns:
            Dictionary with encrypted data and metadata
        """
        # Convert JSON to bytes
        data_bytes = json.dumps(json_data).encode('utf-8')
        
        # Generate AES key
        aes_key = self._generate_aes_key()
        
        # Encrypt data with AES
        iv, encrypted_data = self._encrypt_with_aes(data_bytes, aes_key)
        
        # Encrypt AES key with RSA
        encrypted_key = self._encrypt_aes_key_with_rsa(aes_key)
        
        # Prepare result
        result = {
            "ciphertext": base64.b64encode(encrypted_data).decode('utf-8'),
            "iv": base64.b64encode(iv).decode('utf-8'),
            "encrypted_key": base64.b64encode(encrypted_key).decode('utf-8'),
            "metadata": {
                "encryption_time": datetime.datetime.now().isoformat(),
                "key_version": self.key_manager.get_current_key_version(),
                "totp_window": self.totp_window
            }
        }
        
        return result
    
    def decrypt_json(self, encrypted_data: Dict[str, Any], totp_code: str) -> Optional[Dict[str, Any]]:
        """
        Decrypt JSON data using the provided TOTP code.
        
        Args:
            encrypted_data: Dictionary with encrypted data and metadata
            totp_code: TOTP code for authentication
            
        Returns:
            Decrypted JSON data if TOTP code is valid, None otherwise
        """
        # Extract components
        ciphertext = base64.b64decode(encrypted_data["ciphertext"])
        iv = base64.b64decode(encrypted_data["iv"])
        encrypted_key = base64.b64decode(encrypted_data["encrypted_key"])
        
        # Decrypt AES key with RSA (requires valid TOTP)
        aes_key = self._decrypt_aes_key_with_rsa(encrypted_key, totp_code)
        
        if aes_key is None:
            self.audit_logger.log_event(
                "DECRYPT_ATTEMPT",
                "FAILURE",
                "unknown",
                details="Invalid TOTP code provided"
            )
            return None
            
        # Decrypt data with AES
        decrypted_bytes = self._decrypt_with_aes(ciphertext, aes_key, iv)
        
        # Convert bytes back to JSON
        decrypted_json = json.loads(decrypted_bytes.decode('utf-8'))
        
        self.audit_logger.log_event(
            "DECRYPT_SUCCESS",
            "SUCCESS",
            "authenticated_user",  # In a real system, you'd track the actual user
            details=f"Successfully decrypted data with key version {encrypted_data['metadata']['key_version']}"
        )
        
        return decrypted_json


def main():
    """Command line interface for the encryption system."""
    parser = argparse.ArgumentParser(description="RSA-TOTP Hybrid Encryption System")
    
    # Setup command groups
    subparsers = parser.add_subparsers(dest='command', help='Command to execute')
    
    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize the system')
    init_parser.add_argument('--issuer', required=True, help='Issuer name for TOTP')
    init_parser.add_argument('--user', required=True, help='User email for TOTP')
    init_parser.add_argument('--config-dir', help='Configuration directory')
    
    # Encrypt command
    encrypt_parser = subparsers.add_parser('encrypt', help='Encrypt a JSON file')
    encrypt_parser.add_argument('input', help='Input JSON file path')
    encrypt_parser.add_argument('--output', required=True, help='Output encrypted file path')
    encrypt_parser.add_argument('--config-dir', help='Configuration directory')
    
    # Decrypt command
    decrypt_parser = subparsers.add_parser('decrypt', help='Decrypt an encrypted file')
    decrypt_parser.add_argument('input', help='Input encrypted file path')
    decrypt_parser.add_argument('--output', required=True, help='Output decrypted JSON file path')
    decrypt_parser.add_argument('--totp', required=True, help='TOTP code for authentication')
    decrypt_parser.add_argument('--config-dir', help='Configuration directory')
    
    args = parser.parse_args()
    
    # Process commands
    config_dir = args.config_dir if hasattr(args, 'config_dir') and args.config_dir else "./config"
    crypto = RSATOTPCrypto(config_dir)
    
    if args.command == 'init':
        qr_path = crypto.initialize_system(args.issuer, args.user)
        print(f"System initialized. TOTP QR code saved to: {qr_path}")
        print("Scan this QR code with your authenticator app to set up TOTP.")
        
    elif args.command == 'encrypt':
        # Read JSON data
        with open(args.input, 'r') as f:
            json_data = json.load(f)
            
        # Encrypt data
        encrypted_data = crypto.encrypt_json(json_data)
        
        # Write encrypted data
        with open(args.output, 'w') as f:
            json.dump(encrypted_data, f, indent=2)
            
        print(f"Data encrypted and saved to {args.output}")
        
    elif args.command == 'decrypt':
        # Read encrypted data
        with open(args.input, 'r') as f:
            encrypted_data = json.load(f)
            
        # Decrypt data
        decrypted_data = crypto.decrypt_json(encrypted_data, args.totp)
        
        if decrypted_data is None:
            print("Decryption failed. Invalid TOTP code.")
            sys.exit(1)
            
        # Write decrypted data
        with open(args.output, 'w') as f:
            json.dump(decrypted_data, f, indent=2)
            
        print(f"Data decrypted and saved to {args.output}")
        
    else:
        parser.print_help()
        

if __name__ == "__main__":
    main()